#include "Util.hpp"
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>

#include <vector>
#include <chrono>
#include <time.h>
#include <sstream>

#include "HttpParser.hpp"
pthread_mutex_t LOGGER_MUTEX;

void log_info(const std::string & payload) {

  // use locks to make sure no data race on log file
  pthread_mutex_lock(&LOGGER_MUTEX);
  std::ofstream log_file;

  // open log file in append mode to avoid overwriting log entries generated by other threads
  log_file.open("/var/log/erss/proxy.log", std::ios_base::app);
  if (!log_file.is_open()) {
    return;
  }
  log_file << pthread_self() << ": " << payload << std::endl;
  log_file.close();
  pthread_mutex_unlock(&LOGGER_MUTEX);
}

std::string req_type_repr(RequestType r_type) {
  switch (r_type) {
    case GET:
      return "GET";
    case POST:
      return "POST";

    case CONNECT:
      return "CONNECT";
  }
  return "";
}

RequestType repr_to_req_type(const std::string& repr) {
  if (repr == "GET") {
    return GET;
  } else if (repr == "POST") {
    return POST;
  }

  return CONNECT;
}

std::string lstrip(const std::string& str) {
  size_t start = str.find_first_not_of(" \0");
  if (start == std::string::npos) {
    return "";
  }

  return str.substr(start);
}

std::vector<char> Recv(int fd, bool is_resp) {
  ssize_t rcvd;
  ssize_t should_recv = -1;
  ssize_t total_rcvd = 0;
  std::vector<char> resp;

  std::string resp_header;
  size_t resp_body_start_idx;

  do {
    char buffer[65535 + 1] = {'\0'};
    rcvd = recv(fd, buffer, 65535, 0);
    if (should_recv != -1 && is_resp) {
      total_rcvd += rcvd;
    }

    if (rcvd <= 0) {
      log_info("WARNING " + std::string(getErrorMsg()));
    }
    log_info(buffer);
    for (ssize_t i = 0; i < rcvd; ++i) {
      if (buffer[i] != '\0') {
        resp.push_back(buffer[i]);
      }
    }

    std::pair<bool, size_t> ans = HttpParser::findEmptyLine(resp);
    if (ans.first) {
      resp_body_start_idx = ans.second + 4;

      std::stringstream ss;
      for (size_t i = 0; i < ans.second; ++i) {
        ss << resp[i];
      }

      resp_header = ss.str();
      break;
    }

  } while (rcvd > 0);

  // check content-length or chunked
  std::pair<bool, std::string> transfer_encoding = HttpParser::getTransferEncoding(resp_header);

  // if message is transfered in chunks, receive until
  // 0\r\n\r\n is received
  if (transfer_encoding.first && transfer_encoding.second.compare("chunked") == 0) {
    std::vector<char> chunk;
    std::pair<bool, size_t> chunk_ans;
    while (!HttpParser::isLastChunk(resp)) {
      char buffer[65535 + 1] = {'\0'};
      rcvd = recv(fd, buffer, 65535, 0);
      if (rcvd <= 0) {
        log_info("failed in receiving chunks:\n" + getErrorMsg());
        break;
      }
      log_info("Received chunk:\n" + std::string(buffer));
      for (ssize_t i = 0; i < rcvd; ++i) {
        if (buffer[i] != '\0') {
          resp.push_back(buffer[i]);
        }
      }
    }
  } else {
    // with content length, receive until full message is received
    log_info("receving using content length");
    should_recv = HttpParser::getContentLength(resp_header, POST);
    total_rcvd = resp.size() - resp_body_start_idx;

    while (total_rcvd < should_recv) {
      char buffer[65535 + 1] = {'\0'};
      rcvd = recv(fd, buffer, 65535, 0);
      if (rcvd <= 0) {
        break;
      }
      total_rcvd += rcvd;
      log_info("Received chunk:\n" + std::string(buffer));
      for (ssize_t i = 0; i < rcvd; ++i) {
        if (buffer[i] != '\0') {
          resp.push_back(buffer[i]);
        }
      }
    }
  }

  log_info("Finished receving response");
  return resp;

}

void Send(int fd, const std::vector<char>& payload) {
  ssize_t sent;
  ssize_t should_send = payload.size();
  ssize_t total_sent = 0;
  ssize_t buffer_sent = 0;
  char buffer[65535 + 1] = {'\0'};

  for (size_t i = 0; i < payload.size() && i < 65535; ++i) {
    buffer[i] = payload[i];
  }

  do {
    sent = send(fd, buffer + buffer_sent, strlen(buffer + buffer_sent), 0);
    if (sent < 0) {
      throw std::runtime_error("Error failed to send message: " + getErrorMsg());
    } else if (sent == 0) {
      log_info("Custom send returned zero");
      log_info(getErrorMsg());
      break;
    }
    buffer_sent += sent;
    total_sent += sent;
    log_info("Sent: " + std::to_string(sent));

    // sent out entire payload -> break
    if (total_sent == should_send) {
      break;
    }

    // sent out buffer but not entire payload ->
    //  reload buffer with next chunk
    if (buffer_sent == 65535 && total_sent < should_send) {
      for (ssize_t i = total_sent; i < (ssize_t)payload.size() && i < total_sent + 65535; ++i) {
        buffer[i - total_sent] = payload[i];
      }
      buffer_sent = 0;
    }

    if (buffer_sent > 65535) {
      throw std::runtime_error("invalid number of character sent");
    } 

  } while (buffer_sent <= 65535 && sent > 0);
}

std::string currTime() {
    auto time = std::chrono::system_clock::now();
    std::time_t t = std::chrono::system_clock::to_time_t(time);
    return std::ctime(&t);
}

std::string allToLowercase(const std::string& str) {
  std::stringstream ss;
  for (size_t i = 0; i < str.length(); ++i) {
    ss << std::to_string(std::tolower(str[i]));
  }

  return ss.str();
}

int assignValueOrUnspecified(const std::pair<bool, std::string>& data) {
  int temp = std::stoi(data.second);
  if (temp <= 0) {
    throw std::invalid_argument("cache control attribute less than or equal to 0");
  }
  return data.first ? temp : HttpParser::UNSPECIFIED;
}

std::string getErrorMsg() {
  return std::string(std::strerror(errno));
}

time_t convertToTime(std::string ToConvert){
    tm t;
    strptime(ToConvert.c_str(),"%a, %d %b %Y %H:%M:%S", &t);
    time_t time = mktime(&t);
    if (time == -1)
        /* Handle error */;
    return time;
}

void send_error_code(int fd, int error_code) {
  std::vector<char> msg(100,0);
  if (error_code == 502) {
    strcpy(msg.data(), "HTTP/1.1 502 Bad Gateway\r\n\r\n");
  } else {
    strcpy(msg.data(), "HTTP/1.1 400 Bad Request\r\n\r\n");
  }
  Send(fd, msg);
}

std::string getIpAddr(int fd) {
  struct sockaddr_storage ss;
    socklen_t addrlen = sizeof(ss);
    memset(&ss, 0, sizeof(ss));
    if (getpeername(fd, (struct sockaddr*) &ss, &addrlen) == -1) {
        return "";
    }

    char ipstr[256];
    if (ss.ss_family == AF_INET) {
        //IPv4
        struct sockaddr_in* sa = (struct sockaddr_in*) &ss;
        inet_ntop(AF_INET, &sa->sin_addr, ipstr, 255);
    } else {
        // IPv6
        struct sockaddr_in6* sa6 = (struct sockaddr_in6*) &ss;
        inet_ntop(AF_INET6, &sa6->sin6_addr, ipstr, 255);
    }

    return std::string(ipstr);
}

// example code from https://stackoverflow.com/questions/5141960/get-the-current-time-in-c
std::string getTimeAsString() {
  
  time_t rawtime;
  struct tm* timeinfo;

  time(&rawtime);
  timeinfo = localtime(&rawtime);
  return std::string(asctime(timeinfo));
}

std::string stripNewLine(const std::string& line) {
  std::stringstream ss;
  for (size_t i = 0; i < line.length(); ++i) {
    if (line[i] != '\r' && line[i] != '\n') {
      ss << line[i];
    }
  }

  return ss.str();
}
